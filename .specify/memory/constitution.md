# Evolution of Todo Constitution

<!--
Sync Impact Report:
Version: 1.3.0 → 1.4.0 (MINOR: Comprehensive Phase II Expansion + Gradual Implementation Principle)

Changes:
- Massively expanded Phase II section with comprehensive technical specifications
- Added new Principle VIII: Gradual Feature Implementation
- Added Phase II-specific testing requirements to Development Standards
- Added detailed authentication architecture for Phase II
- Specified complete API endpoint contracts
- Defined monorepo structure with .spec-kit/config.yaml requirements
- Added Phase II Definition of Done (MVP + Production-Ready) matching Phase I detail level
- Added Phase II Feature Implementation Hierarchy with 5 ordered stages
- Specified deployment requirements (Vercel + demo video)

New Sections Added:
1. Principle VIII: Gradual Feature Implementation (emphasizes hierarchical feature building)
2. Phase II: Complete technical specifications including:
   - Gradual Implementation Strategy
   - Technology Stack with versions
   - API Endpoints (6 RESTful routes)
   - Authentication & Security Architecture
   - Monorepo Structure Requirements
   - Data Models (Task, User)
   - Definition of Done (MVP + Production-Ready)
   - Feature Implementation Hierarchy (5 stages)
   - Deliverables

Modified Sections:
- Development Standards: Added Phase II Coverage Requirements (75% MVP, 85% Production-Ready)
- Phase II: Expanded from 13 lines to 180+ lines with production-grade specifications

Templates Requiring Updates:
✅ spec-template.md - already supports priority-based user stories
✅ plan-template.md - already supports web application structure (Option 2)
✅ tasks-template.md - supports gradual implementation via priority ordering
⚠️ Need to create .spec-kit/config.yaml for Phase II monorepo

Rationale for MINOR version bump:
- Significant Phase II material added (from outline to comprehensive spec)
- New Principle VIII added for gradual implementation methodology
- Non-breaking: Phase I remains unchanged, Phase II is additive
- Enables Phase II execution with same rigor as Phase I

Follow-up TODOs:
- Create .spec-kit/config.yaml when starting Phase II (specs_dir: specs, features_dir: specs/features)
- Set up BETTER_AUTH_SECRET environment variable for Phase II authentication
- Configure Neon PostgreSQL connection string in Phase II .env
</thinking>
-->

## Overview

This constitution governs the development of the "Evolution of Todo" project for Hackathon II. It enforces Spec-Driven Development (SDD) using Claude Code and Spec-Kit Plus, shifting the role from syntax writer to system architect. The project evolves a Todo app from a simple CLI to a cloud-native AI system, incorporating Reusable Intelligence through skills and subagents.

## Core Principles

### I. Spec-Driven Development (SDD)

All features MUST start with a Markdown spec. Refine specs iteratively until Claude Code generates correct implementations. No manual coding is allowed—only spec refinement and prompt engineering.

**Rationale**: SDD ensures requirements are clear, testable, and auditable before implementation. It eliminates ambiguity and provides a documented decision trail for judges. Manual coding violates the hackathon's agentic development philosophy.

**Requirements**:
- Every feature MUST have a spec in `/specs/[###-feature-name]/spec.md`
- Specs MUST be refined through Claude Code iterations before implementation
- All spec iterations MUST be tracked in `/specs/[###-feature-name]/history/`
- No code may be written manually—all code MUST be generated by Claude Code

### II. Agentic Dev Stack Workflow

Follow the strict workflow: Write spec → Generate plan → Break into tasks → Implement via Claude Code. Use Spec-Kit Plus for spec management (e.g., init, generate plan, validate).

**Rationale**: This workflow enforces systematic development and leverages Claude Code's strengths. It ensures planning precedes implementation and maintains traceability from requirements to code.

**Requirements**:
- ALL features MUST follow: `/sp.specify` → `/sp.plan` → `/sp.tasks` → `/sp.implement`
- Plans MUST be approved before task generation
- Tasks MUST be approved before implementation
- Document all Claude sessions and prompts in `CLAUDE.md`

### III. Reusable Intelligence

Design modular skills and subagents using the P+Q+P framework (Problem + Query + Plan). Create reusable components like "TaskManagerSkill" for CRUD operations to maximize bonus points.

**Rationale**: Reusable Intelligence demonstrates mastery of agentic patterns and earns +200 bonus points. Modular skills improve maintainability and enable composition of complex behaviors.

**Requirements**:
- Skills MUST follow the P+Q+P framework
- Each skill MUST have clear problem definition, query interface, and execution plan
- Skills MUST be independently testable and reusable across features
- Document skill architecture in `/specs/skills/` for bonus point validation

### IV. Clean Code and Structure

Adhere to Python best practices (PEP8), modular design, and proper project structure. Use UV for dependency management.

**Rationale**: Clean code ensures maintainability, readability, and professional quality expected in hackathon submissions. Proper structure supports scaling from CLI to cloud-native architecture.

**Requirements**:
- ALL Python code MUST conform to PEP8 standards
- MUST use UV for dependency management (Python 3.13+)
- Project structure MUST follow monorepo pattern: `/src/`, `/specs/`, `/tests/`, `/frontend/`, `/backend/` (as phases evolve)
- MUST maintain separation of concerns: models, services, CLI, API layers
- Configuration MUST use environment variables (`.env` files)

### V. No Manual Interventions

Code MUST be generated by Claude Code. Document all Claude sessions, prompts, and iterations in `CLAUDE.md` for judging transparency.

**Rationale**: Manual coding disqualifies the submission per hackathon rules. Complete documentation proves authentic agentic development and helps judges evaluate prompt engineering skill.

**Requirements**:
- Zero manual code writing permitted
- EVERY Claude Code session MUST be documented in `CLAUDE.md`
- MUST record: prompt text, generated code, iteration count, refinements made
- Document failures and how specs were adjusted to achieve success
- Violations invalidate the submission

### VI. Bonus Alignment

Incorporate features that earn bonus points: Reusable Intelligence (+200), Cloud-Native Blueprints (+200), Multi-language Support (Urdu chatbot, +100), Voice Commands (+200).

**Rationale**: Bonus features differentiate submissions and demonstrate advanced capabilities. Strategic alignment maximizes scoring potential (up to +700 points).

**Requirements**:
- Plan bonus features explicitly in spec and plan documents
- Reusable Intelligence: document skills in `/specs/skills/`
- Cloud-Native: implement in Phase IV/V with Docker, K8s, Kafka, Dapr
- Multi-language: add Urdu support in Phase III chatbot
- Voice Commands: integrate voice interface in Phase III or later
- MUST document bonus feature implementation for judge validation

### VII. Ethical and Compliant Development

Ensure user data isolation (e.g., via authentication in later phases), scalability, and alignment with cloud-native principles.

**Rationale**: Professional applications require security, privacy, and scalability. Demonstrating these principles shows production-readiness and responsible engineering.

**Requirements**:
- User data MUST be isolated per user (implement auth in Phase II+)
- MUST follow principle of least privilege for access control
- Sensitive data (passwords, tokens) MUST use secure storage (env vars, secrets managers)
- MUST implement proper error handling without leaking sensitive information
- Design MUST support horizontal scaling (stateless services in cloud phases)

### VIII. Gradual Feature Implementation

Features MUST be implemented in logical, hierarchical order. Each stage MUST be fully functional and testable before proceeding to the next. Build complexity incrementally—foundation before dependent features.

**Rationale**: Gradual implementation reduces risk, enables early validation, and ensures a working application at every stage. This approach prevents big-bang integration failures and allows course correction after each milestone. It aligns with agile principles and provides judges with clear progression evidence.

**Requirements**:
- Features MUST be ordered by dependency (e.g., database setup before API, API before frontend)
- Each feature stage MUST have independent acceptance criteria
- MUST validate and test each stage before starting the next
- Document the feature hierarchy in plan.md with explicit stage ordering
- Each stage MUST be committable and deployable independently
- Integration between stages MUST be testable in isolation

## Development Standards

### Testing Requirements
- **TDD Mandatory**: Write tests BEFORE implementation for all features
- **Phase I Coverage**: Minimum 70% for MVP, 80% for production-ready
- **Phase II Coverage**: Minimum 75% for MVP, 85% for production-ready
- **Test Structure**: Mirror src/ in tests/ (e.g., `src/models/task.py` → `tests/unit/models/test_task.py`)
- **Test Categories**: Unit tests in `tests/unit/`, integration tests in `tests/integration/`, e2e tests in `tests/e2e/`
- **Test Execution**: Run `pytest` (backend) and test framework (frontend) before marking any task complete

### Version Control & Branching
- **Branch Naming**: `###-feature-name` format (e.g., `001-cli-todo-app`, `002-database-setup`)
- **Feature Numbering**: Start at 001, increment sequentially per feature
- **Commit Frequency**: Commit after each completed task from tasks.md
- **Commit Format**: `feat(scope): description` for features, `fix(scope): description` for bugs
- **Example**: `git checkout -b 002-database-setup` then `git commit -m "feat(db): configure neon postgresql connection"`

### Environment Setup
- **Virtual Environment**: Use `uv venv` to create, `source .venv/bin/activate` to activate
- **Environment Variables**: Create `.env` files for each service (root, backend, frontend)
- **Phase I Variables**: `LOG_LEVEL=DEBUG`, `APP_NAME=evolution-todo`
- **Phase II Variables**: Add `DATABASE_URL`, `BETTER_AUTH_SECRET`, `JWT_SECRET`, `FRONTEND_URL`, `BACKEND_URL`
- **Dependencies**: Manage via `uv add <package>` and `uv pip compile` for lock files

### Approval Process
- **Spec Approval**: User reviews and confirms spec.md in chat before running `/sp.plan`
- **Plan Approval**: User reviews and confirms plan.md in chat before running `/sp.tasks`
- **Task Approval**: User reviews and confirms tasks.md in chat before running `/sp.implement`
- **Mechanism**: Claude Code will pause and request explicit approval at each transition

### Code Documentation
- **Docstrings**: All public functions MUST have Google-style docstrings
- **Required Sections**: Description, Args, Returns, Raises (if applicable)
- **Example**:
  ```python
  def add_task(title: str, description: str) -> dict:
      """Add a new task to the task list.

      Args:
          title: Task title (required, non-empty)
          description: Task description (optional)

      Returns:
          dict: Created task with id, title, description, complete fields

      Raises:
          ValueError: If title is empty
      """
  ```

### Logging Standards
- **Library**: Python standard `logging` module
- **Format**: `%(asctime)s - %(name)s - %(levelname)s - %(message)s`
- **Levels**: DEBUG for development, INFO for production, ERROR for failures
- **Requirement**: Log all CRUD operations at INFO level

## Phase-Specific Guidelines

### Phase I: In-Memory Python Console App

**Scope**: Implement Basic Level features (Add Task, Delete Task, Update Task, View Task List, Mark as Complete) in a CLI app with in-memory storage.

**Data Structure**: Use a list of dictionaries (e.g., `{'id': int, 'title': str, 'description': str, 'complete': bool}`).

**Interface**: Menu-driven CLI with user prompts.

**Technology**: Python 3.13+, UV, Claude Code, Spec-Kit Plus.

**Deliverables**:
- Specs in `/specs/` (with history tracking)
- Source in `/src/`
- `CLAUDE.md` with all sessions documented
- `README.md` with setup and usage instructions

**Definition of Done (MVP)**:
- ✅ All 5 basic features implemented and working (Add, Delete, Update, View, Mark Complete)
- ✅ In-memory storage functional with proper data structure
- ✅ Menu-driven CLI with user prompts and error handling
- ✅ 70%+ test coverage (verified with `pytest --cov`)
- ✅ All code PEP8 compliant (verified with `ruff check`)
- ✅ README.md with setup and usage instructions
- ✅ CLAUDE.md with all sessions documented
- ✅ All tests passing (`pytest` exits with 0)

**Definition of Done (Production-Ready)**:
- All MVP criteria PLUS:
- ✅ 80%+ test coverage
- ✅ Input validation for all edge cases
- ✅ Comprehensive error handling with user-friendly messages
- ✅ All functions have Google-style docstrings
- ✅ Logging implemented for all CRUD operations

**Phase I Feature Requirements** (implementation order):
- **High (Must Have for MVP)**: Add Task, View Task List, Mark Complete
- **Medium (Should Have)**: Update Task, Delete Task
- **Normal (Nice to Have)**: Input validation enhancements, colored CLI output

**Note**: The High/Medium/Low terminology above refers to which features must be implemented for MVP. This is separate from the task priority field (High/Medium/Low) that users set when adding tasks to their todo list.

**Branch**: `001-cli-todo-app`

### Phase II: Full-Stack Web Application

**Scope**: Transform the Phase I CLI application into a multi-user full-stack web application with persistent storage. Implement all Basic Level features (Add, Delete, Update, View, Mark Complete) as a web app supporting multiple users with authentication and database persistence. Features MUST be implemented gradually in hierarchical order per Principle VIII.

**Gradual Implementation Strategy**: Build features in ordered stages, each independently functional and testable. Start with foundational infrastructure (database, models), then backend API, then authentication, then frontend, finally integration. Each stage MUST be validated before proceeding.

**Technology Stack**:
- **Frontend**: Next.js 16+ (App Router), React 19+, TailwindCSS 3+
- **Backend**: FastAPI 0.115+, Python 3.13+
- **ORM**: SQLModel 0.0.22+
- **Database**: Neon Serverless PostgreSQL (cloud-hosted)
- **Authentication**: Better Auth (frontend), JWT validation (backend)
- **Development Tools**: UV (Python dependencies), pnpm (Node dependencies)
- **Deployment**: Vercel (frontend + backend as serverless functions)
- **Spec-Driven**: Claude Code + Spec-Kit Plus

**Monorepo Structure**:
```text
/
├── .spec-kit/
│   └── config.yaml          # Define specs_dir: specs, features_dir: specs/features
├── specs/
│   ├── overview.md          # High-level Phase II architecture
│   ├── architecture.md      # System design and component interactions
│   ├── features/
│   │   ├── [002-database-setup]/
│   │   ├── [003-task-crud-api]/
│   │   ├── [004-authentication]/
│   │   ├── [005-frontend-ui]/
│   │   └── [006-integration]/
│   ├── api/
│   │   └── rest-endpoints.md     # API contracts and schemas
│   ├── database/
│   │   └── schema.md             # Database models and relationships
│   └── ui/
│       ├── components.md         # Frontend component specifications
│       └── pages.md              # Page-level requirements
├── backend/
│   ├── src/
│   │   ├── models/          # SQLModel database models
│   │   ├── services/        # Business logic layer
│   │   ├── api/             # FastAPI routes and endpoints
│   │   ├── middleware/      # JWT validation, CORS, logging
│   │   └── main.py          # FastAPI application entry
│   ├── tests/
│   │   ├── unit/
│   │   ├── integration/
│   │   └── e2e/
│   ├── .env                 # Backend environment variables
│   ├── pyproject.toml       # UV dependencies
│   └── CLAUDE.md            # Backend development sessions
├── frontend/
│   ├── src/
│   │   ├── app/             # Next.js App Router pages
│   │   ├── components/      # React components (UI, forms, layouts)
│   │   ├── services/        # API client, auth utilities
│   │   └── lib/             # Shared utilities
│   ├── tests/
│   ├── .env.local           # Frontend environment variables
│   ├── package.json         # pnpm dependencies
│   └── CLAUDE.md            # Frontend development sessions
├── CLAUDE.md                # Root project sessions
├── docker-compose.yml       # Local development environment (optional)
└── README.md                # Complete setup instructions
```

**API Endpoints** (RESTful):
- `GET /api/{user_id}/tasks` - List all tasks for authenticated user
- `POST /api/{user_id}/tasks` - Create new task with title and description
- `GET /api/{user_id}/tasks/{id}` - Retrieve single task details by ID
- `PUT /api/{user_id}/tasks/{id}` - Update task title, description, or status
- `DELETE /api/{user_id}/tasks/{id}` - Delete task by ID
- `PATCH /api/{user_id}/tasks/{id}/complete` - Toggle task completion status

**Request/Response Format**:
```json
// POST /api/{user_id}/tasks
{
  "title": "Task title",
  "description": "Task description"
}

// Response (201 Created)
{
  "id": 1,
  "user_id": "user-uuid",
  "title": "Task title",
  "description": "Task description",
  "complete": false,
  "created_at": "2025-12-18T10:00:00Z",
  "updated_at": "2025-12-18T10:00:00Z"
}
```

**Authentication & Security Architecture**:
- **Frontend (Better Auth)**:
  - User signup/signin with email and password
  - Better Auth issues JWT tokens on successful authentication
  - Store JWT in secure HttpOnly cookies or localStorage
  - Attach JWT in `Authorization: Bearer <token>` header for all API calls
  - Implement protected routes (redirect to login if not authenticated)

- **Backend (JWT Validation)**:
  - Add middleware to verify JWT signature using shared secret
  - Extract `user_id` from validated JWT payload
  - Filter all database queries by authenticated `user_id`
  - Return 401 Unauthorized for missing or invalid tokens
  - Enforce task ownership (users can only access their own tasks)

- **Shared Secret**: Set `BETTER_AUTH_SECRET` environment variable in both frontend and backend

- **Security Requirements**:
  - MUST validate JWT on every backend request
  - MUST filter all data by authenticated user_id
  - MUST use HTTPS in production (Vercel provides this)
  - MUST NOT expose user data across accounts
  - MUST implement rate limiting on authentication endpoints

**Data Models**:

**Task Model** (SQLModel):
```python
class Task(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    user_id: str = Field(index=True, nullable=False)
    title: str = Field(max_length=200, nullable=False)
    description: str | None = Field(default=None, max_length=1000)
    complete: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**User Model** (Better Auth handles user storage, backend only needs user_id):
- Backend does NOT store user credentials
- Better Auth manages user table (email, hashed password, etc.)
- Backend receives user_id from validated JWT
- Backend Task model references user_id as foreign key concept

**Definition of Done (MVP)**:
- ✅ Database schema created in Neon PostgreSQL with Task model
- ✅ All 6 API endpoints implemented and functional
- ✅ Authentication: signup, signin, JWT validation working
- ✅ Backend enforces user data isolation (tasks filtered by user_id)
- ✅ Frontend: signup/signin pages, task list, add/edit/delete forms
- ✅ Frontend: responsive design with TailwindCSS
- ✅ Integration: frontend successfully calls backend API with JWT
- ✅ 75%+ test coverage for backend (verified with `pytest --cov`)
- ✅ All backend code PEP8 compliant (verified with `ruff check`)
- ✅ All backend tests passing (`pytest` exits with 0)
- ✅ Frontend builds successfully (`npm run build` succeeds)
- ✅ Both services documented in respective CLAUDE.md files
- ✅ README.md with complete setup instructions (database, env vars, running locally)
- ✅ Deployed to Vercel and publicly accessible
- ✅ Demo video (<90 seconds) showing: signup, signin, add task, view tasks, edit task, delete task, mark complete

**Definition of Done (Production-Ready)**:
- All MVP criteria PLUS:
- ✅ 85%+ test coverage for backend
- ✅ Frontend unit tests for components and services
- ✅ E2E tests covering critical user journeys
- ✅ Comprehensive error handling (network failures, validation errors, auth errors)
- ✅ Input validation on both frontend and backend
- ✅ Loading states and user feedback for all async operations
- ✅ Proper CORS configuration for production domains
- ✅ Database connection pooling and retry logic
- ✅ Logging for all API requests and errors
- ✅ Rate limiting on authentication endpoints
- ✅ Security headers (CSP, HSTS, X-Frame-Options)
- ✅ All functions have Google-style docstrings

**Phase II Feature Implementation Hierarchy** (MUST follow this order):

**Stage 1: Foundation - Database & Models** (Branch: `002-database-setup`)
- Set up Neon PostgreSQL database
- Configure DATABASE_URL environment variable
- Implement SQLModel Task model
- Create database migration scripts
- Write unit tests for model validation
- **Acceptance**: Can create/read Task records programmatically

**Stage 2: Backend API - CRUD Operations** (Branch: `003-task-crud-api`)
- Implement FastAPI application structure
- Create all 6 API endpoints (GET, POST, PUT, DELETE, PATCH)
- Add request/response validation with Pydantic
- Implement service layer for business logic
- Write integration tests for all endpoints
- **Acceptance**: API endpoints work with curl/Postman (no auth yet)

**Stage 3: Authentication & Security** (Branch: `004-authentication`)
- Set up Better Auth on frontend for user management
- Implement JWT validation middleware in backend
- Add user_id filtering to all database queries
- Configure BETTER_AUTH_SECRET in both services
- Implement protected API routes
- Write tests for authentication flow
- **Acceptance**: Only authenticated users can access their tasks

**Stage 4: Frontend UI** (Branch: `005-frontend-ui`)
- Set up Next.js 16 with App Router
- Create signup/signin pages with Better Auth integration
- Implement task list page with CRUD forms
- Add TailwindCSS styling and responsive design
- Implement API client service with JWT header injection
- Add loading states and error handling
- **Acceptance**: Full UI works with mock API data

**Stage 5: Integration & Deployment** (Branch: `006-integration`)
- Connect frontend to backend API
- Configure CORS for Vercel deployment
- Set up environment variables in Vercel
- Deploy both services to Vercel
- Run E2E tests against deployed application
- Record demo video showing all features
- **Acceptance**: Deployed app fully functional, demo video complete

**Branch Sequence**: `002-database-setup` → `003-task-crud-api` → `004-authentication` → `005-frontend-ui` → `006-integration`

**Deliverables**:
- GitHub repository with complete Phase II implementation
- Constitution file (this document) at `.specify/memory/constitution.md`
- Specs in `/specs/` with history tracking for each feature
- Source code split into `/backend/` and `/frontend/` directories
- CLAUDE.md files in root, backend, and frontend (all sessions documented)
- README.md with comprehensive setup instructions
- Deployed application on Vercel (provide URL)
- Demo video (<90 seconds) demonstrating:
  1. User signup and signin
  2. Adding a new task
  3. Viewing task list
  4. Editing a task
  5. Deleting a task
  6. Marking task as complete
  7. Data isolation (create second user, verify separate task lists)

**Constitution Compliance**:
- MUST maintain SDD workflow with separate specs for each feature stage
- MUST follow gradual implementation per Principle VIII
- MUST implement authentication per Principle VII (user data isolation)
- MUST document API contracts in `/specs/api/rest-endpoints.md`
- MUST use monorepo structure per Principle IV
- MUST achieve Definition of Done before claiming Phase II complete

### Phase III: AI-Powered Chatbot

**Scope**: Add conversational AI interface using OpenAI Agents SDK or MCP SDK. Support natural language task management. Include Urdu support (+100 bonus).

**Technology**: OpenAI Agents SDK, MCP SDK, LangChain/LlamaIndex (optional).

**Constitution Compliance**:
- Design chatbot as Reusable Intelligence component (Principle III)
- Multi-language support earns bonus points (Principle VI)
- Consider voice command integration (+200 bonus)

### Phase IV: Local Kubernetes Deployment

**Scope**: Containerize with Docker, deploy to Minikube with multi-pod architecture, add Kafka for event streaming.

**Technology**: Docker, Minikube, Kafka, Dapr (sidecar pattern).

**Constitution Compliance**:
- Cloud-Native Blueprints (+200 bonus, Principle VI)
- Demonstrate scalability (Principle VII)
- Document infrastructure as code in `/specs/infrastructure/`

### Phase V: Advanced Cloud & Orchestration

**Scope**: Kubernetes orchestration, Dapr integration, advanced AI features, comprehensive observability.

**Technology**: Kubernetes, Dapr, Prometheus, Grafana, OpenTelemetry.

**Constitution Compliance**:
- Complete cloud-native transformation
- Full observability and monitoring (aligns with professional quality)
- Demonstrate all bonus features if implemented

## Governance

This constitution supersedes all other practices. Amendments require:
1. Documented rationale for change
2. Approval from project lead or team consensus
3. Migration plan for impacted specs and code
4. Version increment per semantic versioning

All pull requests and reviews MUST verify compliance with this constitution. Complexity MUST be justified (reference Principle IV and plan-template.md Complexity Tracking section). Any code generated by Claude Code MUST be traced to its originating spec.

Use `CLAUDE.md` for runtime development guidance and session tracking.

**Version**: 1.4.0 | **Ratified**: 2025-12-17 | **Last Amended**: 2025-12-18
