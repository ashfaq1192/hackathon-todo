# Data Model: CLI Todo App

**Feature**: CLI Todo App with Basic CRUD Operations
**Date**: 2025-12-17
**Phase**: Phase 1 - Data Model Design

## Overview

This document defines the data structures, validation rules, and state transitions for the CLI Todo App. The application uses in-memory storage with a list-based data structure.

## Entity: Task

### Structure

A Task is represented as a Python dictionary with the following schema:

```python
{
    "id": int,           # Unique identifier, auto-generated, never reused
    "title": str,        # Task title, required, non-empty
    "description": str,  # Task details, optional, can be empty
    "priority": str,     # Urgency level: "High", "Medium", or "Low"
    "complete": bool     # Completion status, defaults to False
}
```

### Field Specifications

#### id (integer)
- **Type**: `int`
- **Generation**: Auto-generated by service layer, starting from 1
- **Uniqueness**: Guaranteed unique within session
- **Immutability**: Never changes after creation
- **Reuse Policy**: Never reused after task deletion (monotonically increasing)
- **Validation**: Not user-provided, always valid
- **Example**: `1`, `2`, `3`, `4` (after deleting ID 2, next ID is still 4, not 2)

#### title (string)
- **Type**: `str`
- **Required**: Yes (user must provide)
- **Validation Rules**:
  - Cannot be empty string
  - Cannot be only whitespace
  - Trimmed via `str.strip()` before storage
- **Max Length**: No explicit limit (reasonable CLI input expected)
- **Mutability**: Can be updated via Update Task operation
- **Error Messages**:
  - Empty: "Title cannot be empty"
  - Whitespace only: "Title cannot be empty"
- **Example**: `"Buy groceries"`, `"Complete project proposal"`

#### description (string)
- **Type**: `str`
- **Required**: No (optional)
- **Validation Rules**:
  - Can be empty string
  - No trimming applied (preserves user formatting)
- **Max Length**: No explicit limit
- **Mutability**: Can be updated via Update Task operation
- **Default**: Empty string `""`
- **Example**: `"Milk, bread, eggs"`, `""` (empty is valid)

#### priority (string)
- **Type**: `str`
- **Required**: Yes (user must provide)
- **Validation Rules**:
  - Must be exactly one of: `"High"`, `"Medium"`, `"Low"`
  - Case-sensitive (e.g., `"high"`, `"HIGH"` are invalid)
- **Mutability**: Can be updated via Update Task operation
- **Error Message**: "Priority must be exactly 'High', 'Medium', or 'Low'"
- **Semantic Meaning** (from spec):
  - **High**: Critical tasks crucial for main goals, must be completed immediately
  - **Medium**: Important tasks without immediate urgency, scheduled after High priority work
  - **Low**: Tasks that can be postponed or delegated, minimal impact if left undone
- **Example**: `"High"`, `"Medium"`, `"Low"`

#### complete (boolean)
- **Type**: `bool`
- **Required**: No (system-generated)
- **Default**: `False` (tasks start incomplete)
- **Validation**: Always valid boolean
- **Mutability**: Toggled via Mark Complete/Incomplete operation
- **Toggle Behavior**: Can switch from False→True or True→False
- **Example**: `False`, `True`

### Example Task Instances

```python
# Newly created task
{
    "id": 1,
    "title": "Buy groceries",
    "description": "Milk, bread, eggs",
    "priority": "High",
    "complete": False
}

# Completed task
{
    "id": 2,
    "title": "Review pull request",
    "description": "",  # Empty description is valid
    "priority": "Medium",
    "complete": True
}

# Task with minimal description
{
    "id": 3,
    "title": "Call dentist",
    "description": "",
    "priority": "Low",
    "complete": False
}
```

## Storage Structure

### In-Memory Task List

**Data Structure**: Python list of task dictionaries

```python
tasks: list[dict] = []  # Module-level variable in task_service.py
```

**Properties**:
- Mutable list, modified in-place during CRUD operations
- No persistence: cleared when application exits
- Single source of truth for all task data
- Access: Encapsulated within `task_service.py`, not directly accessible by CLI layer

**Operations**:
- **Read**: `tasks[index]` or `[t for t in tasks if t["id"] == task_id]`
- **Create**: `tasks.append(new_task)`
- **Update**: Modify task dict in-place via reference
- **Delete**: `tasks.remove(task)` or `tasks = [t for t in tasks if t["id"] != task_id]`

### ID Counter

**Data Structure**: Module-level integer

```python
next_id: int = 1  # Module-level variable in task_service.py
```

**Properties**:
- Monotonically increasing
- Never decrements
- Incremented on each task creation: `next_id += 1`
- Persists across create/delete operations within session
- Reset to 1 on application restart (expected behavior)

## State Transitions

### Task Lifecycle

```
[Created] → complete=False
    ↓
[Active] ⟷ [Completed]
complete=False ⟷ complete=True
    ↓
[Deleted] (removed from list)
```

### State Transition Rules

#### Creation (Add Task)
- **Initial State**: Task does not exist
- **Operation**: User provides title, description, priority
- **Validation**: Title non-empty, priority valid
- **New State**: Task added to list with `complete=False`, auto-generated ID
- **Side Effects**: `next_id` incremented

#### Completion Toggle (Mark Complete/Incomplete)
- **Initial State**: Task with `complete=False` or `complete=True`
- **Operation**: User specifies task ID
- **Validation**: Task ID exists
- **New State**: `complete` flips to opposite boolean value
- **Side Effects**: None

#### Update (Partial or Full)
- **Initial State**: Task exists with current field values
- **Operation**: User specifies task ID and one or more fields (title, description, priority)
- **Validation**:
  - Task ID exists
  - If title provided: non-empty
  - If priority provided: valid value
- **New State**: Specified fields updated, others unchanged
- **Side Effects**: None

#### Deletion (Delete Task)
- **Initial State**: Task exists in list
- **Operation**: User specifies task ID
- **Validation**: Task ID exists
- **New State**: Task removed from list permanently
- **Side Effects**: ID is never reused (no decrement of `next_id`)

## Validation Rules Summary

### Field-Level Validation

| Field | Validation Rule | Error Message |
|-------|----------------|---------------|
| **title** | `len(title.strip()) > 0` | "Title cannot be empty" |
| **description** | Always valid (can be empty) | N/A |
| **priority** | `priority in ["High", "Medium", "Low"]` | "Priority must be exactly 'High', 'Medium', or 'Low'" |
| **id** (for operations) | `id in [t["id"] for t in tasks]` | "Task not found" |
| **id** (for operations) | `isinstance(id, int) and id > 0` | "Invalid task ID" |

### Operation-Level Validation

| Operation | Additional Validation |
|-----------|----------------------|
| **Add Task** | Title and priority required (not None) |
| **Update Task** | At least one field must be provided (not all None) |
| **Mark Complete** | No additional validation beyond ID existence |
| **Delete Task** | No additional validation beyond ID existence |
| **View Tasks** | No validation (always succeeds, may show empty list) |

## Sorting and Display Rules

### Task List Sort Order

**Multi-level sort key**: `(complete, priority_order, id)`

1. **Primary sort**: Completion status (incomplete before completed)
   - `False` (incomplete) sorts before `True` (completed)

2. **Secondary sort**: Priority (High → Medium → Low)
   - Mapped to numeric order: `{"High": 0, "Medium": 1, "Low": 2}`

3. **Tertiary sort**: ID ascending (oldest first within same priority/status)
   - Numeric comparison: `1, 2, 3, 4, ...`

**Sort Implementation**:
```python
priority_order = {"High": 0, "Medium": 1, "Low": 2}
sorted_tasks = sorted(
    tasks,
    key=lambda t: (t["complete"], priority_order[t["priority"]], t["id"])
)
```

**Sort Examples**:

Given tasks:
- ID 1: High, incomplete
- ID 2: Low, incomplete
- ID 3: Medium, incomplete
- ID 4: High, complete
- ID 5: Low, complete

Sorted display order:
1. ID 1 (High, incomplete)
2. ID 3 (Medium, incomplete)
3. ID 2 (Low, incomplete)
4. ID 4 (High, complete)
5. ID 5 (Low, complete)

### Display Format

**Required Fields**: ID, title, description, priority, completion status

**Format** (to be defined in CLI layer):
- Each task on separate lines or in table format
- Clear indication of completion status
- Priority visible for user prioritization

## Invariants

### System Invariants (Must Always Hold)

1. **ID Uniqueness**: No two tasks in the list have the same ID
   - Enforced by: Auto-increment counter, never reused

2. **ID Monotonicity**: `next_id` always greater than any existing task ID
   - Enforced by: Increment on create, never decrement on delete

3. **Priority Values**: All tasks have priority in `["High", "Medium", "Low"]`
   - Enforced by: Validation on create and update

4. **Title Non-Empty**: All tasks have non-empty trimmed title
   - Enforced by: Validation on create and update

5. **Boolean Complete**: All tasks have `complete` as `True` or `False`
   - Enforced by: Default value on create, toggle operation only

### Non-Invariants (Can Change)

- **Task Count**: Can be 0 (empty list is valid)
- **Description Length**: Can be 0 (empty string is valid)
- **ID Gaps**: IDs can have gaps after deletion (e.g., 1, 3, 5 after deleting 2 and 4)
- **Priority Distribution**: No requirement for balanced priority counts

## Error Handling

### Validation Errors (User-Correctable)

- Empty title → Prompt user to provide non-empty title
- Invalid priority → Display valid options and prompt again
- Non-existent task ID → Inform user task not found, show available IDs
- Invalid ID format (non-numeric) → Inform user to enter numeric ID

### System Errors (Unexpected)

- Out of memory → Application crash (acceptable for MVP)
- Python runtime errors → Application crash (acceptable for MVP, no error recovery needed)

## Future Considerations (Phase II+)

### Planned Changes for Persistence

When migrating to Phase II (PostgreSQL):
- **id**: Change from int counter to database SERIAL primary key
- **created_at**: Add timestamp field for creation date
- **updated_at**: Add timestamp field for last modification
- **user_id**: Add foreign key for multi-user support
- **Storage**: Migrate from list to SQLAlchemy ORM models

### Data Migration Notes

Current dictionary structure maps cleanly to database table:
```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    priority VARCHAR(6) NOT NULL CHECK (priority IN ('High', 'Medium', 'Low')),
    complete BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    user_id INTEGER REFERENCES users(id)
);
```

No breaking changes to field names or types needed for Phase II migration.
