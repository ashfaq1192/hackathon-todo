# Data Model: Database & Models Setup

**Date**: 2025-12-18
**Feature**: 002-database-setup
**Phase**: Phase 1 - Data Model Design

## Overview

This document defines the data model for Stage 1 (Database & Models Setup). Stage 1 establishes the Task entity as the core data structure for persistent storage.

---

## Entity: Task

### Purpose
Represents a single todo item with metadata for multi-user task management.

### Table Name
`tasks`

### Fields

| Field | Type | Constraints | Default | Description |
|-------|------|-------------|---------|-------------|
| `id` | Integer | PRIMARY KEY, AUTO INCREMENT | Auto | Unique task identifier |
| `user_id` | String | NOT NULL, INDEXED | - | Owner of the task (references Better Auth user) |
| `title` | String(200) | NOT NULL | - | Task title/summary |
| `description` | String(1000) | NULLABLE | `NULL` | Optional detailed description |
| `complete` | Boolean | NOT NULL | `False` | Completion status |
| `created_at` | DateTime (UTC) | NOT NULL | `utcnow()` | Timestamp when task was created |
| `updated_at` | DateTime (UTC) | NOT NULL | `utcnow()` | Timestamp of last modification |

### Indexes

1. **Primary Key**: `id` (auto-generated)
2. **User ID Index**: `user_id` (for efficient user-specific queries)

### Validation Rules

From functional requirements (FR-004 to FR-008):

1. **user_id**:
   - MUST NOT be NULL or empty string
   - Type: String (matches Better Auth user ID format)
   - Indexed for query performance

2. **title**:
   - MUST NOT be NULL
   - MUST NOT exceed 200 characters
   - Raise validation error if empty or too long

3. **description**:
   - OPTIONAL (can be NULL)
   - MUST NOT exceed 1000 characters if provided

4. **complete**:
   - MUST default to `False` for new tasks
   - Boolean type (True/False only)

5. **Timestamps (created_at, updated_at)**:
   - Auto-generated on insert (created_at)
   - Auto-updated on modification (updated_at)
   - Stored as UTC datetime

### State Transitions

```
[New Task] → complete=False (default)
           ↓
[Mark Complete] → complete=True
           ↓
[Mark Incomplete] → complete=False
```

State changes affect `updated_at` timestamp automatically.

### SQLModel Implementation

```python
from datetime import datetime
from typing import Optional
from sqlmodel import Field, SQLModel

class Task(SQLModel, table=True):
    """
    Task model for persistent todo storage.

    Attributes:
        id: Auto-generated primary key
        user_id: Owner of the task (indexed for multi-user queries)
        title: Task title (required, max 200 chars)
        description: Optional detailed description (max 1000 chars)
        complete: Completion status (defaults to False)
        created_at: Creation timestamp (auto-generated UTC)
        updated_at: Last modification timestamp (auto-updated UTC)
    """
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(index=True, nullable=False)
    title: str = Field(max_length=200, nullable=False)
    description: Optional[str] = Field(default=None, max_length=1000)
    complete: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        sa_column_kwargs={"onupdate": datetime.utcnow}
    )

    class Config:
        """Pydantic config for SQLModel."""
        json_schema_extra = {
            "example": {
                "user_id": "user_abc123",
                "title": "Complete Phase II Stage 1",
                "description": "Set up database with Neon and SQLModel",
                "complete": False
            }
        }
```

---

## Relationships

### Current Stage (Stage 1)
- **Task → User**: Conceptual relationship via `user_id` string field
- No foreign key constraint (User table managed by Better Auth in Stage 3)
- Multi-user isolation enforced by application logic (query filtering by user_id)

### Future Stages
- **Stage 3 (Authentication)**: `user_id` will reference Better Auth user table
- Potential foreign key constraint if Better Auth exposes User model
- Cascade delete behavior TBD based on Better Auth integration

---

## Database Schema (PostgreSQL DDL)

Auto-generated by SQLModel from Task model:

```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR NOT NULL,
    title VARCHAR(200) NOT NULL,
    description VARCHAR(1000),
    complete BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX ix_tasks_user_id ON tasks(user_id);
```

**Note**: Actual DDL generated by SQLModel may vary slightly. Use `SQLModel.metadata.create_all()` for automatic table creation.

---

## CRUD Operations (Stage 1 Scope)

### Create Task
```python
def create_task(session: Session, user_id: str, title: str, description: str | None = None) -> Task:
    task = Task(user_id=user_id, title=title, description=description)
    session.add(task)
    session.commit()
    session.refresh(task)
    return task
```

### Read Task by ID
```python
def get_task_by_id(session: Session, task_id: int) -> Task | None:
    return session.get(Task, task_id)
```

### Read Tasks by User ID
```python
from sqlmodel import select

def get_tasks_by_user(session: Session, user_id: str) -> list[Task]:
    statement = select(Task).where(Task.user_id == user_id)
    return session.exec(statement).all()
```

**Out of Scope for Stage 1**: Update, Delete operations (deferred to Stage 2)

---

## Validation Examples

### Valid Task Creation
```python
task = Task(
    user_id="user_123",
    title="Buy groceries",
    description="Milk, eggs, bread"
)
# ✅ Valid: All required fields present, within constraints
```

### Invalid Task Creation (Validation Errors)

```python
# ❌ Missing user_id
task = Task(title="Task without user")
# Raises: ValidationError (user_id required)

# ❌ Title too long
task = Task(user_id="user_123", title="x" * 201)
# Raises: ValidationError (title max 200 chars)

# ❌ Empty user_id
task = Task(user_id="", title="Task")
# Raises: ValidationError (user_id cannot be empty)
```

---

## Edge Cases Handling

From spec edge cases section:

1. **user_id is empty string vs None**:
   - Solution: SQLModel validation rejects both (nullable=False, non-empty string)

2. **title exceeds 200 chars**:
   - Solution: Pydantic validation raises error before database insert

3. **Duplicate task IDs**:
   - Solution: PostgreSQL PRIMARY KEY constraint enforces uniqueness

4. **description is None vs empty string**:
   - Solution: Both allowed (nullable field), stored as NULL or "" respectively

---

## Testing Checklist

Data model validation tests (from User Story 2 acceptance scenarios):

- [ ] Create Task with valid data (user_id, title, description) succeeds
- [ ] Create Task without user_id raises ValidationError
- [ ] Create Task with title > 200 chars raises ValidationError
- [ ] New Task has complete=False by default
- [ ] New Task has auto-generated created_at and updated_at
- [ ] Timestamps are UTC datetime objects
- [ ] description=None is valid (nullable field)
- [ ] user_id="" (empty string) raises ValidationError

---

## Migration Path (Future)

Stage 1 uses `SQLModel.metadata.create_all()` for automatic table creation.

**Future Stages**:
- Add Alembic when schema changes needed
- Initial migration: Capture current Task model as baseline
- Schema evolution: Migrations for new fields, indexes, relationships

**Current Approach**: No migrations needed for Stage 1 (single static model)

---

## Summary

**Entity Count**: 1 (Task)
**Relationships**: None (user_id is string reference, no FK yet)
**Validation Rules**: 5 (user_id, title, description, complete, timestamps)
**Indexes**: 2 (primary key on id, index on user_id)
**CRUD Scope**: Create, Read (Update/Delete in Stage 2)

**Dependencies**:
- SQLModel 0.0.22+ (ORM + validation)
- Pydantic (validation engine, included in SQLModel)
- PostgreSQL 12+ (Neon Serverless)

**Next Phase**: Define contracts (minimal for Stage 1), create quickstart guide
